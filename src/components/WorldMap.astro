---
import worldMapSvg from '../assets/images/whattoexpect/worldmap.svg';
---
<div class="map-wrapper">
<h2 class="section-title center">Global Network of Headshot Photographers</h2>
<div class="WorldMapSection">
        
        <div class="world-map-container">
        <img 
            src={worldMapSvg.src}
            alt="world map"
            class="world-map-background"
        />
        <svg
            class="world-map-svg"
            viewBox="0 0 800 400"
            preserveAspectRatio="xMidYMid meet"
        >
            <defs>
            <linearGradient id="path-gradient" x1="0%" y1="0%" x2="100%" y2="0%">
                <stop offset="0%" stop-color="white" stop-opacity="0" />
                <stop offset="5%" stop-color="#0ea5e9" stop-opacity="1" />
                <stop offset="95%" stop-color="#0ea5e9" stop-opacity="1" />
                <stop offset="100%" stop-color="white" stop-opacity="0" />
            </linearGradient>
            
            <filter id="glow">
                <feMorphology operator="dilate" radius="0.5" />
                <feGaussianBlur stdDeviation="1" result="coloredBlur" />
                <feMerge>
                <feMergeNode in="coloredBlur" />
                <feMergeNode in="SourceGraphic" />
                </feMerge>
            </filter>
            </defs>

            <g id="paths-container"></g>
            <g id="points-container"></g>
        </svg>

        </div>

        <div class="text">
            
            
           <p> My work doesn’t stop at a single city or studio. I collaborate with a global network of professional headshot photographers across the United States and internationally, which allows me to support clients wherever their people are located. If your team spans multiple offices, states, or countries, you are not limited by geography, and neither am I.</p>

            <p>When I’ve already worked with a client, this network becomes an extension of that relationship. I coordinate directly with trusted photographers in other locations to ensure your team members receive the same level of care, direction, and attention to detail. The goal is simple: no visual disconnect, no mismatched styles, and no surprises when images are placed side by side.</p>

            <p>The result is a consistent, cohesive set of headshots that feels intentional across your entire organization and your brand. One visual standard. One professional presence. No matter where your people happen to be working.</p>


        </div>

</div>
</div>




<script>
  import { gsap } from 'gsap';

  const dots = [
    { start: { lat: 64.2008, lng: -149.4937, label: "Fairbanks" }, end: { lat: 34.0522, lng: -118.2437, label: "Los Angeles" } },
    { start: { lat: 34.0522, lng: -118.2437, label: "Los Angeles" }, end: { lat: 40.038578, lng: -76.306020, label: "Lancaster" } },
    { start: { lat: -15.7975, lng: -47.8919, label: "Brazil" }, end: { lat: 38.7223, lng: -9.1393, label: "Lisbon" } },
    { start: { lat: 51.5074, lng: -0.1278, label: "London" }, end: { lat: 31.7769, lng: 35.2224, label: "Jerusalem" } },
    { start: { lat: 28.6139, lng: 77.209, label: "New Delhi" }, end: { lat: 35.6764, lng: 139.6500, label: "Tokyo" } },
    { start: { lat: 28.6139, lng: 77.209, label: "New Delhi" }, end: { lat: 0.0236, lng: 37.9062, label: "Kenya" } },
    { start: { lat: 35.6764, lng: 139.6500, label: "Tokyo" }, end: { lat: 0.0236, lng: 151.2093, label: "Sydney" } }
  ];

  const lineColor = "var(--accent)";
  const showLabels = true;
  const animationDuration = 1.5;
  const loop = true;
  const staggerDelay = 0.3;
  const totalAnimationTime = dots.length * staggerDelay + animationDuration;
  const pauseTime = .25;
  const fullCycleDuration = totalAnimationTime + pauseTime;
 

  interface Point { x: number; y: number; }

  function projectPoint(lat: number, lng: number): Point {
    const x = (lng + 180) * (800 / 360);
    const y = (90 - lat) * (400 / 180);
    return { x, y };
  }

  function createCurvedPath(start: Point, end: Point): string {
    const midX = (start.x + end.x) / 2;
    const midY = Math.min(start.y, end.y) - 50;
    return `M ${start.x} ${start.y} Q ${midX} ${midY} ${end.x} ${end.y}`;
  }

  function initMap() {
    const pathsContainer = document.getElementById('paths-container');
    const pointsContainer = document.getElementById('points-container');
    if (!pathsContainer || !pointsContainer) return;
    
    pathsContainer.innerHTML = '';
    pointsContainer.innerHTML = '';

    dots.forEach((dot, i) => {
      const startPoint = projectPoint(dot.start.lat, dot.start.lng);
      const endPoint = projectPoint(dot.end.lat, dot.end.lng);
      const pathData = createCurvedPath(startPoint, endPoint);
      const startTime = (i * staggerDelay) / fullCycleDuration;
      const endTime = (i * staggerDelay + animationDuration) / fullCycleDuration;
      // const resetTime = totalAnimationTime / fullCycleDuration;
      const resetTime = (totalAnimationTime / fullCycleDuration) - .05;

      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('d', pathData);
      path.setAttribute('fill', 'none');
      path.setAttribute('stroke', 'url(#path-gradient)');
      path.setAttribute('stroke-width', '1');
      pathsContainer.appendChild(path);

      const pathLength = path.getTotalLength();
      if (loop) {
        gsap.fromTo(path, { strokeDasharray: pathLength, strokeDashoffset: pathLength }, {
          strokeDashoffset: pathLength,
          duration: fullCycleDuration,
          ease: "power2.inOut",
          repeat: -1,
          keyframes: [
            { strokeDashoffset: pathLength, duration: startTime * fullCycleDuration },
            { strokeDashoffset: 0, duration: (endTime - startTime) * fullCycleDuration },
            { strokeDashoffset: 0, duration: (resetTime - endTime) * fullCycleDuration },
            { strokeDashoffset: pathLength, duration: (1 - resetTime) * fullCycleDuration }
          ]
        });
      }

      [startPoint, endPoint].forEach((pt, index) => {
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', pt.x.toString());
        circle.setAttribute('cy', pt.y.toString());
        circle.setAttribute('r', '3');
        circle.setAttribute('fill', lineColor);
        circle.setAttribute('filter', 'url(#glow)');
        circle.classList.add('location-point');

        const pulse = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        pulse.setAttribute('cx', pt.x.toString());
        pulse.setAttribute('cy', pt.y.toString());
        pulse.setAttribute('r', '3');
        pulse.setAttribute('fill', lineColor);
        pulse.setAttribute('opacity', '0.5');

        const animR = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
        animR.setAttribute('attributeName', 'r');
        animR.setAttribute('from', '3');
        animR.setAttribute('to', '12');
        animR.setAttribute('dur', '2s');
        animR.setAttribute('begin', index === 0 ? '0s' : '0.5s');
        animR.setAttribute('repeatCount', 'indefinite');

        const animO = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
        animO.setAttribute('attributeName', 'opacity');
        animO.setAttribute('from', '0.6');
        animO.setAttribute('to', '0');
        animO.setAttribute('dur', '2s');
        animO.setAttribute('begin', index === 0 ? '0s' : '0.5s');
        animO.setAttribute('repeatCount', 'indefinite');

        pulse.append(animR, animO);
        g.append(circle, pulse);
        pointsContainer.appendChild(g);

        const labelData = index === 0 ? dot.start : dot.end;
        if (showLabels && labelData.label) {
          const label = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
          label.setAttribute('x', (pt.x - 50).toString());
          label.setAttribute('y', (pt.y - 35).toString());
          label.setAttribute('width', '100');
          label.setAttribute('height', '30');
          label.classList.add('pointer-events-none');
          label.innerHTML = `<div class="label-wrapper"><span class="label-text">${labelData.label}</span></div>`;
          pointsContainer.appendChild(label);
          gsap.from(label, { opacity: 0, y: 5, duration: 0.5, delay: 0.5 * i + (index === 0 ? 0.3 : 0.5) });
        }
      });
    });
  }

  document.addEventListener('astro:page-load', () => {
    function setupObserver() {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => { if (entry.isIntersecting) { initMap(); observer.unobserve(entry.target); } });
      }, { threshold: 0.1 });

      const target = document.querySelector('.WorldMapSection');
      if (target) observer.observe(target);
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', setupObserver);
    } else {
      setupObserver();
    }
  });
</script>


<style>

.map-wrapper{
  padding-block:var(--size-8);
}



   h2{
    text-wrap:pretty;
    width:calc(100% - (var(--size-9)));
    margin-inline:auto;
    margin-bottom:var(--size-7);
   } 

.WorldMapSection{
    width:calc(100% - (var(--size-7)));
    margin-inline:auto;
    display:grid;
    grid-template-columns: 1fr; 
    gap:var(--size-8);
    
}


  .world-map-container {
    width:100%;
    width:90%;
    /* width: clamp(20rem, 90vw, 60rem);    */
    /* width:calc(100% - var(--size-7)); */
    margin-inline:auto;
    /* aspect-ratio: 2 / 1; */
    background: white;
    position: relative;
    overflow: hidden;
    font-family: var(--ff-primary);

    
  }

  .world-map-background {
    height: 100%;
    width: 100%;
    mask-image: linear-gradient(to bottom, transparent, white 10%, white 90%, transparent);
    -webkit-mask-image: linear-gradient(to bottom, transparent, white 10%, white 90%, transparent);
    pointer-events: none;
    user-select: none;
    object-fit: cover;
    
   
  }

  .world-map-svg {
    width: 100%;
    height: 100%;
    position: absolute;
    inset: 0;
    pointer-events: auto;
    user-select: none;
  }

  .location-point {
    cursor: pointer;
    filter: drop-shadow(0 10px 8px rgb(0 0 0 / 0.04)) drop-shadow(0 4px 3px rgb(0 0 0 / 0.1));

    
  }

  .pointer-events-none {
    pointer-events: none;
  }

  .label-wrapper {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
    
  }

  :global(.label-text) {
    font-size: var(--fs-275);
    font-weight: 500;
    padding: 0.125rem 0.5rem;
    border-radius: 0.375rem;
    background: rgba(255, 255, 255, 0.95);
    color: black;
    border: 1px solid #e5e7eb;
    box-shadow: 0 1px 2px 0 var(--shadow-clr-subtle);
  }


  /* ==========================================
   TABLET - min-width: 48em (768px)
   ========================================== */

  @media (min-width: 48em) {
    .WorldMapSection{
      grid-template-columns: 1fr;
      padding:var(--size-8);
      margin-inline:auto;
      gap:var(--size-8);
  }
    .world-map-container {
    
  }

  /* ==========================================
   DESKTOP - min-width: 64em (1024px)
   ========================================== */

  @media (min-width: 64em) {

    .world-map-container {
      /* width:100%; */
      padding: var(--size-7);
      margin-inline:auto;
     
    
  
    }
  }

  /* ==========================================
   LARGE DESKTOP - min-width: 90em (1440px)
   ========================================== */
    
    @media (width >= 90em){
      .WorldMapSection{
        /* grid-template-columns:1fr 2fr; */
        grid-template-columns: minmax(0, 1fr) minmax(0, 1.3fr);    
        align-items: center;
        line-height:var(--line-height-loose);
      }

  .world-map-container {
    /* max-inline-size:calc(100% - var(--size-12)); */
    margin-inline:auto;
  }

  .text{
    max-width:75%;
    margin-inline:auto;
  }
}

</style>